#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-

#Copyright (C) 2015  David Delgado Hernandez 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.


"""
    Este archivo iniciara el entorno para la descarga de los videos
"""
import getopt
import sys
import logging
import os

this_dir = os.path.dirname(os.path.abspath(__file__))
trunk_dir = os.path.split(this_dir)[0]
sys.path.insert(0,trunk_dir)

from ikol.youtube.APIRequest import APIRequest
from ikol.youtube.Auth import Authorized
from ikol.dbregister import DataBase
from ikol.config import Config
from ikol.downloader.Downloader import Downloader
from ikol.directory import Directorio

# Declaracion global
config = Config()
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s : %(levelname)s : %(message)s',
    filename = config.getLogFile(),
    filemode='a')


####################### Funciones de Apoyo #######################

def getAuth():
    
    # Objeto del que se obtendran la conexiones con el api
    Auth = Authorized(config.client_secret)
    Auth.getFlow()
    Auth.setStorage(config.storage_path)
    service = Auth.getService()

    return service


def RevisarPlaylist(playlist):
    # Obtiene los datos de la playlist 
    # Devuelve los id de las canciones en lista
    idname = playlist.partition("playlist?list=")[2]
    S = getAuth()
    API = APIRequest(S)
    # verificar la existencia de la playlist
    if not idname in API.getSecondPeer(API.getPlaylists()):
        # TODO : Retirar de lista de playlist
        print "La playlist " + idname +" no existe"
        logging.warning("La playlist " + idname +" no existe")
        videos = []
        return  
    videos = API.getVideosList(idname)

    return videos


def getHistory(playlist):
    # Obtener todos los archivos que ya se descargaron en el pasado
    # Si no existe registro de la playlist crearlo
    idname = playlist.partition("playlist?list=")[2]
    DB = DataBase()
    # TODO : Crea varias entradas en la base de datos
    if DB.playlistExist(idname) == False:        
        API = APIRequest(getAuth())
        lstname = API.getNameList(idname)
        DB.insertPlaylist(playlist,lstname)

    videohst = DB.getAllVideosByPlaylist(idname)

    return videohst

def FiltrarRepetidos(video,videohst):
    # Se recibe la lista que proporciona la api 
    # asi que se deben separar la tupla luego comparar con el historial +
    # devolver una lista de tuplas con videos repetidos eliminados
    # [(name,idvideo)]
    for i in video:
        for x in videohst:
            if i[1] == x[0]:
                # Eliminar el elemento de la lista video
                logging.debug(i[1]+ " video repetido" )
                video.remove(i)
                continue
    return video

def Download(playlist,videos):
    # Descargar los videos
    # Crear un directorio con el nombre de la playlist en el directorio cache
    idname = playlist.partition("playlist?list=")[2]
    print "Preparandose para descargar " + idname
    logging.info("Descargando " + idname)
    API = APIRequest(getAuth())
    lstname = API.getNameList(idname)

    DB = DataBase()
    cache = os.path.join(config.getCacheDir(),lstname)
    D = Directorio(cache)
    logging.info("Directorio cache "+ cache)
    # Separar la lista de videos,nombre descargar el video
    ready = []
    for i in videos:
        # Descargar el video
        idvideo = i[1]
        url = API.FormatURL(idvideo)
        Down = Downloader(url)
        # TODO : Genera un retardo
        Down.setFormat(config.getFormat())
        Down.setCacheDir(D.path)
        print "Descargando video " + i[0]
        logging.info("Inicio Descarga " + i[0])
        if Down.download():
            # Si todo salio bien registrarlo en el historial
            # Obtener el nombre del archivo 
            path = os.path.splitext(i[0])[0] +"."+ Down.ext
            print "Descarga de " + path + " finalizo correctamente"
            logging.info("Descarga de " + path + " finalizada")

            if D.FileinDir(path):
                path = D.FileinDir(path)
                # Renombrar el archivo para Filtrar Caracteres non-ascii
                path = D.CleanName(path)
                DB.insertVideo(idvideo,idname,path)
                ready.append(path)
            else:
                print "Error Al buscar el archivo " + path
                logging.debug("Error al buscar el archivo " + path)
        else:
            print "Error al descargar el video " +i[0]
            logging.warning("Error al descargar el video " +i[0])

    logging.debug("Archivos listos " + str(ready))
    return ready

def moveToDest(listfiles):
    # Mover los archivos correctos al directorio destino
    D = Directorio(os.path.dirname(listfiles[0]))
    dest = config.getFinalDir()

    for i in listfiles:
        try:

            print "Moviendo "+ D.path +" hacia " + dest
            logging.debug("Moviendo " + dest)
            D.moveToDest(i,dest)
        except Exception, e:
            #TODO : hacer algo con este error decode ascii en print
            print e
            logging.debug(e)


def options(argv):
    # leer los argumentos de linea de comandos
    # Armar el objeto config para la configuracion global
    keys = {
        "url" : "",
        "format" : 0,
        "cache" : "",
        "regurl": False,
        "regformat" : False,
        "regcache" : False,
        "force" : False,
        "regdest" : False,
        "dest" : ""
    }
    # TODO : Lanzar excepciones que detengan la ejecucion del programa
    try:
        options , arg = getopt.getopt(argv, "A:a:v:f:F:c:C:D:i",
                        ["add-url=","url=","video=","format=","set-format=",
                        "cache=","dir-cache=,Destino=,force"])

    except getopt.GetoptError:
        # TODO : Manejar errores
        print "el argumento no es valido"

    for opt , arg in options:
        
        if opt in ("-A","--add-url"):
            if arg:
                keys["url"] = arg
                keys["regurl"] = True
            else:
                print "La opcion necesita un argumento"

        if opt in ("-a","--url"):
            if arg:
                keys["url"] = arg
            else:
                print "La opcion necesita un argumento"

        if opt in ("-v","--video"):
            if arg:
                keys["url"] = arg
            else:
                print "La opcion necesita un argumento"

        if opt in ("-f","--format"):
            if arg:
                keys["format"] = int(arg)
            else:
                print "La opcion necesita un argumento"

        if opt in ("-F","--set-format"):
            if arg:
                keys["format"] = int(arg)
                keys["regformat"] = True
            else:
                print "La opcion necesita un argumento"

        if opt in ("-c","--cache"):
            if arg:
                keys["cache"] = arg
            else:
                print "La opcion necesita un argumento"

        if opt in ("-C","--dir-cache"):
            if arg:
                keys["cache"] = arg
                keys["regcache"] = True
            else:
                print "La opcion necesita un argumento"

        if opt in ("-D","--Destino"):
            if arg:
                keys["regdest"] = True
                keys["dest"] = arg
            else:
                "La opcion necesita un argumento"

        if opt in ("-i","--force"):
            keys["force"] == True

    return keys


def ArmarConfig(keys):
    urllst = []

    # Resolver todas las configuraciones
    # Devuelve una lista con todas las url encontradas

    if keys["regcache"]:
        config.setCacheDir(keys["cache"],True)
    elif keys["cache"] != "":
        config.setCacheDir(keys["cache"])

    if keys["regformat"]:
        config.setFormat(keys["format"],True)
    elif keys["format"] != 0:
        config.setFormat(keys["format"])

    if keys["regdest"]:
        config.setFinalDir(keys["dest"])

    if keys["regurl"]:
        config.addURL(keys["url"])
    else:
        # Agregar lista a objeto downloader
        urllst.append(keys["url"])

    return urllst



####################### Codigo Principal #######################


if __name__ == '__main__':
    logging.info("\n\nInicio de operaciones")
    # Devuelve una diccionario con los argumentos establecidos
    keys  = options(sys.argv[1:])

    urllst = ArmarConfig(keys)

    # Obtener las Url del archivo y unirlas a la lista
    lst = config.getAllURL()

    for i in lst:
        if len(i) > 0:
            urllst.append(i)

    for i in urllst:
        if len(i) == 0:
            urllst.remove(i)
    logging.debug("urllst "+ str(urllst))

    for i in urllst:
        # TODO : Realizar el multihilo
        videos = RevisarPlaylist(i)
        if len(videos) == 0:
            # Saltarse la playlist
            logging.warning("Playlist vacia" + i)
            print i + "vacia"
            continue

        historial = getHistory(i)

        if keys["force"] == False:
            # Descargar todos los videos sin tomar en cuenta el historial
            videos = FiltrarRepetidos(videos,historial)

        # Descargar los Videos
        cache = Download(i,videos)
        # Mover al directorio definido por el usuario
        moveToDest(cache)
        # Eliminar los archivos erroneos

    logging.info("Finaliza operaciones")
